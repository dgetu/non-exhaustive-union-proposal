{"version":3,"file":"extensibleUnion.js","sourceRoot":"","sources":["../src/extensibleUnion.ts"],"names":[],"mappings":"AAaA,SAAS,SAAS;IAChB,OAAO,KAAY,CAAC;AACtB,CAAC;AAED,SAAS,UAAU;IACjB,mDAAmD;IACnD,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAyB,CAAC;AAC3D,CAAC;AAqBD,WAAW;AAEX,yCAAyC;AAEzC,GAAG,EAAE;IACH,MAAM,GAAG,GAAQ,gDAAiE,CAAC;IACnF,mBAAmB;IACnB,wDAAwD;IACxD,2DAA2D;IAC3D,MAAM,GAAG,GACP,wEAA+E,CAAC;AACpF,CAAC,CAAC;AAEF,GAAG,EAAE;IACH,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;IAC3B,IAAI,MAAM,KAAK,KAAK,EAAE,CAAC;QACrB,2DAA2D;QAC3D,MAAM,GAAG,GAAU,MAAM,CAAC;IAC5B,CAAC;SAAM,CAAC;QACN,yFAAyF;QACzF,uCAAuC;QACvC,mBAAmB;QACnB,qEAAqE;QACrE,6DAA6D;QAC7D,MAAM,GAAG,GAAW,MAAM,CAAC;QAC3B,2CAA2C;QAC3C,mBAAmB;QACnB,0EAA0E;QAC1E,mDAAmD;QACnD,MAAM,IAAI,GAAU,MAAM,CAAC;QAC3B,0FAA0F;QAC1F,IAAK,MAAiB,KAAK,KAAK,EAAE,CAAC;YACjC,MAAM,IAAI,GAAU,MAAe,CAAC;QACtC,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEF,GAAG,EAAE;IACH,MAAM,MAAM,GAAG,UAAU,EAAE,CAAC;IAC5B,IAAI,MAAM,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;QAC1B,2DAA2D;QAC3D,MAAM,GAAG,GAAU,MAAM,CAAC,IAAI,CAAC;QAC/B,MAAM,IAAI,GAAW,MAAM,CAAC,GAAG,CAAC;IAClC,CAAC;SAAM,CAAC;QACN,yFAAyF;QACzF,uCAAuC;QACvC,mBAAmB;QACnB,qEAAqE;QACrE,6DAA6D;QAC7D,MAAM,IAAI,GAAW,MAAM,CAAC,IAAI,CAAC;QACjC,4FAA4F;QAC5F,mBAAmB;QACnB,gGAAgG;QAChG,oDAAoD;QACpD,MAAM,IAAI,GAAW,MAAM,CAAC,GAAG,CAAC;QAChC,uDAAuD;QACvD,IAAK,MAAM,CAAC,IAAe,KAAK,KAAK,EAAE,CAAC;YACtC,MAAM,GAAG,GAAa,MAA6B,CAAC,GAAG,CAAC;QAC1D,CAAC;IACH,CAAC;AACH,CAAC,CAAC;AAEF,8CAA8C;AAC9C,SAAS,IAAI,CAAC,GAAQ;IACpB,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;QAClB,OAAO;IACT,CAAC;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAED,iGAAiG;AACjG,kGAAkG;AAClG,yCAAyC;AACzC,SAAS,GAAG,CAAC,GAAQ;IACnB,sDAAsD;IACtD,mBAAmB;IACnB,8FAA8F;IAC9F,eAAe;IACf,EAAE;IACF,mFAAmF;IACnF,OAAO,GAAG,CAAC;AACb,CAAC;AAOD,SAAS,OAAO,CAAC,GAAQ;IACvB,IAAI,GAAG,KAAK,KAAK,EAAE,CAAC;QAClB,OAAO;IACT,CAAC;IACD,mBAAmB;IACnB,8FAA8F;IAC9F,uFAAuF;IACvF,OAAO,GAAG,CAAC;AACb,CAAC;AAOD,SAAS,GAAG,CAAC,GAAW;IACtB,yBAAyB;IACzB,mDAAmD;IACnD,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["declare const Unknown: unique symbol;\n\nexport type Extensible<T, Default> = T | UnknownVariant<Default>;\ntype UnknownVariant<Default> = Default extends object ? UnknownObject<Default> : typeof Unknown;\ntype UnknownObject<Default extends object> = {\n  [K in keyof Default]: UnknownVariant<Default[K]>;\n};\n\ntype OldFoo = Extensible<\"foo\", string>;\ntype Foo = Extensible<\"foo\" | \"bar\", string>;\ntype OldFooUnion = Extensible<FooType, { kind: string }>;\ntype FooUnion = Extensible<FooType | BarType, { kind: string }>;\n\nfunction operation(): Foo {\n  return \"baz\" as Foo;\n}\n\nfunction operation2(): FooUnion {\n  // New API surface that isn't exposed in the client\n  return { kind: \"baz\", baz: true } as unknown as FooUnion;\n}\n\ninterface FooBase {\n  kind: Foo;\n}\n\ninterface FooType extends FooBase {\n  kind: \"foo\";\n  foo: string;\n}\n\ninterface BarType extends FooBase {\n  kind: \"bar\";\n  bar: number;\n}\n\ninterface BazType {\n  kind: \"baz\";\n  baz: boolean;\n}\n\n// userland\n\n// Table stakes: is it an extensible enum\n\n() => {\n  const foo: Foo = \"Adding a variant doesn't break this assignment\" as \"foo\" | \"bar\";\n  // @ts-expect-error\n  // Type 'Foo' is not assignable to type '\"foo\" | \"bar\"'.\n  //  Type '\"baz\"' is not assignable to type '\"foo\" | \"bar\"'.\n  const bar: \"foo\" | \"bar\" =\n    \"This assignment never works, even if there are no variants in the enum\" as Foo;\n};\n\n() => {\n  const result = operation();\n  if (result === \"foo\") {\n    // Can be coerced to the specific variant with a type guard\n    const foo: \"foo\" = result;\n  } else {\n    // Even though the kind should default to something like `string`, we don't have a way to\n    // inform the type system of that fact.\n    // @ts-expect-error\n    // Type 'string | typeof Unknown' is not assignable to type 'string'.\n    //  Type 'typeof Unknown' is not assignable to type 'string'.\n    const foo: string = result;\n    // This continues to cause a build failure.\n    // @ts-expect-error\n    // Type '\"baz\" | \"bar\" | unique symbol' is not assignable to type '\"bar\"'.\n    //  Type '\"baz\"' is not assignable to type '\"bar\"'.\n    const foo2: \"bar\" = result;\n    // If the user expects a shape that's unknown at generation time, they can use a type cast\n    if ((result as string) === \"baz\") {\n      const foo3: \"baz\" = result as \"baz\";\n    }\n  }\n};\n\n() => {\n  const result = operation2();\n  if (result.kind === \"foo\") {\n    // Can be coerced to the specific variant with a type guard\n    const foo: \"foo\" = result.kind;\n    const foo2: string = result.foo;\n  } else {\n    // Even though the kind should default to something like `string`, we don't have a way to\n    // inform the type system of that fact.\n    // @ts-expect-error\n    // Type 'string | typeof Unknown' is not assignable to type 'string'.\n    //  Type 'typeof Unknown' is not assignable to type 'string'.\n    const kind: string = result.kind;\n    // Even if it's the last variant, `result` isn't a \"bar\" until it goes through a type guard.\n    // @ts-expect-error\n    // Property 'bar' does not exist on type 'BarType | BazType | UnknownObject<{ kind: string; }>'.\n    //  Property 'bar' does not exist on type 'BazType'.\n    const bar2: number = result.bar;\n    // This typecast continues to have the correct behavior\n    if ((result.kind as string) === \"baz\") {\n      const baz: boolean = (result as unknown as BazType).baz;\n    }\n  }\n};\n\n// Some constructed types don't cause problems\nfunction good(foo: Foo): Exclude<Foo, \"foo\"> | undefined {\n  if (foo === \"foo\") {\n    return;\n  }\n  return foo;\n}\n\n// A user could easily fall into this trap. We shouldn't make it easy for them to construct their\n// own extensible unions with our unique symbol. Avoid exposing the symbol type, or any parametric\n// types that allow someone to extend it.\nfunction bad(foo: Foo): Extensible<\"foo\", string> | undefined {\n  // Error expected when `Foo` is extended with `\"bar\"`.\n  // @ts-expect-error\n  // Type '\"foo\" | \"bar\" | unique symbol' is not assignable to type 'Extensible<\"foo\", string> |\n  //  undefined'.\n  //\n  //  Type '\"bar\"' is not assignable to type 'Extensible<\"foo\", string> | undefined'.\n  return foo;\n}\n\n// Assume the user names this symbol with the same name. Unique symbols have a type that's unique to\n// their instance, so unless we export the symbol, the user has no way to access its type directly.\n// This means that there's no way to make this compile in userland. Users have to cast, which means\n// we won't break them if we add a known variant. But some users...\ndeclare const DeterminedUser: unique symbol;\nfunction niceTry(foo: Foo): \"bar\" | typeof DeterminedUser | undefined {\n  if (foo === \"foo\") {\n    return;\n  }\n  // @ts-expect-error\n  // Type '\"bar\" | unique symbol' is not assignable to type '\"bar\" | unique symbol | undefined'.\n  //  Type 'unique symbol' is not assignable to type '\"bar\" | unique symbol | undefined'.\n  return foo;\n}\n\n// ...will find a way to shoot themselves in the foot. We'll need to think about how users might\n// construct edge cases like this in normal use, and how much type magic we care to entertain before\n// we stop supporting it.\ntype Footgun<T> = T extends string ? never : T;\ntype Problem = Footgun<Foo>;\nfunction why(foo: OldFoo): \"foo\" | Problem {\n  // Error is expected here\n  // This breaks when `Foo` is extended with `\"bar\"`.\n  return foo;\n}\n"]}