{"version":3,"file":"extensibleUnion.js","sourceRoot":"","sources":["../src/extensibleUnion.ts"],"names":[],"mappings":"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","sourcesContent":["declare const Unknown: unique symbol;\n\nexport type Extensible<T, Default> = T | UnknownVariant<Default>;\ntype UnknownVariant<Default> = Default extends object ? UnknownObject<Default> : typeof Unknown;\ntype UnknownObject<Default extends object> = {\n  [K in keyof Default]: UnknownVariant<Default[K]>;\n};\n\ntype Foo = Extensible<\"foo\" | \"bar\" | \"baz\", string>;\ntype FooUnion = Extensible<FooType | BarType | BazType, { kind: string }>;\n\nfunction operation(): Foo {\n  return \"baz\" as Foo;\n}\n\nfunction operation2(): FooUnion {\n  return { kind: \"baz\", baz: true };\n}\n\nfunction operation3(): FooType | BarType {\n  return { kind: \"baz\", baz: true } as unknown as FooType | BarType;\n}\n\ninterface FooBase {\n  kind: Foo;\n}\n\ninterface FooType extends FooBase {\n  kind: \"foo\";\n  foo: string;\n}\n\ninterface BarType extends FooBase {\n  kind: \"bar\";\n  bar: number;\n}\n\ninterface BazType {\n  kind: \"baz\";\n  baz: boolean;\n}\n\n// userland\n\n// Table stakes: is it an extensible enum\n\n() => {\n  const foo: Foo = \"Adding a variant doesn't break this assignment\" as \"foo\" | \"bar\";\n  // @ts-expect-error\n  // Type 'Foo' is not assignable to type '\"foo\" | \"bar\"'.\n  //  Type '\"baz\"' is not assignable to type '\"foo\" | \"bar\"'.\n  const bar: \"foo\" | \"bar\" =\n    \"This assignment never works, even if there are no variants in the enum\" as Foo;\n};\n\n() => {\n  const result = operation();\n  if (result === \"foo\") {\n    // Can be coerced to the specific variant with a type guard\n    const foo: \"foo\" = result;\n  } else {\n    // Even though the kind should default to something like `string`, we don't have a way to\n    // inform the type system of that fact.\n    // @ts-expect-error\n    // Type 'string | typeof Unknown' is not assignable to type 'string'.\n    //  Type 'typeof Unknown' is not assignable to type 'string'.\n    const foo: string = result;\n    // This continues to cause a build failure.\n    // @ts-expect-error\n    // Type '\"baz\" | \"bar\" | unique symbol' is not assignable to type '\"bar\"'.\n    //  Type '\"baz\"' is not assignable to type '\"bar\"'.\n    const foo2: \"bar\" = result;\n    // If the user expects a shape that's unknown at generation time, they can use a type cast\n    if ((result as string) === \"baz\") {\n      const foo3: \"baz\" = result as \"baz\";\n    }\n  }\n};\n\n() => {\n  const result = operation2();\n  if (result.kind === \"foo\") {\n    // Can be coerced to the specific variant with a type guard\n    const foo: \"foo\" = result.kind;\n    const foo2: string = result.foo;\n  } else {\n    // Even though the kind should default to something like `string`, we don't have a way to\n    // inform the type system of that fact.\n    // @ts-expect-error\n    // Type 'string | typeof Unknown' is not assignable to type 'string'.\n    //  Type 'typeof Unknown' is not assignable to type 'string'.\n    const kind: string = result.kind;\n    // Even if it's the last variant, `result` isn't a \"bar\" until it goes through a type guard.\n    // @ts-expect-error\n    // Property 'bar' does not exist on type 'BarType | BazType | UnknownObject<{ kind: string; }>'.\n    //  Property 'bar' does not exist on type 'BazType'.\n    const bar2: number = result.bar;\n    const asdf: FooUnion = { kind: \"sfjn\" };\n    // This typecast continues to have the correct behavior\n    if ((result.kind as string) === \"baz\") {\n      const baz: boolean = (result as unknown as BazType).baz;\n    }\n  }\n};\n\n() => {\n  const result = operation3();\n  if (result.kind === \"foo\") {\n    // Some sanity checks for assignability\n    const fooKindLiteralType: { kind: \"foo\"; foo: string } = result;\n    const fooKind: FooType = result;\n    const kind: \"foo\" = result.kind;\n  } else {\n    // Exactly the same as above, but suppose the user somehow knows this is a \"baz\" even though\n    // it's not an extensible enum\n    const baz: { kind: \"baz\"; baz: string } = result as unknown as {\n      kind: \"baz\";\n      baz: string;\n    };\n  }\n};\n\n// Some constructed types don't cause problems\nfunction good(foo: Foo): Exclude<Foo, \"foo\"> | undefined {\n  if (foo === \"foo\") {\n    return;\n  }\n  return foo;\n}\n\n// A user could easily fall into this trap. We shouldn't make it easy for them to construct their\n// own extensible unions with our unique symbol. Avoid exposing the symbol type, or any generics\n// that allow someone to extend it.\nfunction bad(foo: Foo): Extensible<\"bar\", string> | undefined {\n  if (foo === \"foo\") {\n    return;\n  }\n  // Error expected when `Foo` is extended with `\"baz\"`.\n  // @ts-expect-error\n  // Type '\"bar\" | \"baz\" | unique symbol' is not assignable to type 'Extensible<\"bar\", string> | undefined'.\n  //  Type '\"baz\"' is not assignable to type 'Extensible<\"bar\", string> | undefined'.\n  return foo;\n}\n\n// Assume the user names this symbol with the same name. Unique symbols have a type that's unique\n// to their instance, so unless we export the symbol, the user has no way to access its type\n// directly. This means that there's no way to make this compile in userland without a cast. But\n// some users...\ndeclare const DeterminedUser: unique symbol;\nfunction niceTry(foo: Foo): \"bar\" | typeof DeterminedUser | undefined {\n  if (foo === \"foo\") {\n    return;\n  }\n  // @ts-expect-error\n  // Type '\"bar\" | \"baz\" | unique symbol' is not assignable to type '\"bar\" | unique symbol | undefined'.\n  //  Type '\"baz\"' is not assignable to type '\"bar\" | unique symbol | undefined'.\n  return foo;\n}\n\n// ...will find a way to shoot themselves in the foot. We'll need to think about how users might\n// construct edge cases like this in normal use, and how much type magic we care to entertain\n// before we stop supporting it.\ntype Footgun<T> = T extends string ? never : T;\ntype Problem = Footgun<Foo>;\nfunction why(foo: Foo): \"bar\" | Problem | undefined {\n  if (foo === \"foo\") {\n    return;\n  }\n  // Error expected when `Foo` is extended with `\"baz\"`.\n  // @ts-expect-error\n  // Type '\"bar\" | \"baz\" | unique symbol' is not assignable to type '\"bar\" | unique symbol | undefined'.\n  //  Type '\"baz\"' is not assignable to type '\"bar\" | unique symbol | undefined'.\n  return foo;\n}\n"]}