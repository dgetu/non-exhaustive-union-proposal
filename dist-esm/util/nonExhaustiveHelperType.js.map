{"version":3,"file":"nonExhaustiveHelperType.js","sourceRoot":"","sources":["../../src/util/nonExhaustiveHelperType.ts"],"names":[],"mappings":"AAmCA,SAAS,SAAS,CAAC,KAAY;IAC7B,OAAO,KAAK,CAAC;AACf,CAAC;AAED,uBAAuB;AACvB,MAAM,UAAU,GAAU,KAAK,CAAC;AAChC,wBAAwB;AACxB,MAAM,YAAY,GAAU,OAAO,CAAC;AACpC,MAAM,WAAW,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;AAE1C,IAAI,WAAW,KAAK,KAAK,EAAE,CAAC;IAC1B,qDAAqD;IACrD,MAAM,GAAG,GAAU,WAAoB,CAAC;AAC1C,CAAC;KAAM,CAAC;IACN,sFAAsF;IACtF,4BAA4B;IAC5B,mBAAmB;IACnB,MAAM,SAAS,GAAW,WAAW,CAAC;IACtC,IAAI,WAAW,KAAK,MAAM,EAAE,CAAC;QAC3B,qDAAqD;QACrD,MAAM,IAAI,GAAW,WAAqB,CAAC;IAC7C,CAAC;SAAM,CAAC;QACN,IAAI,WAAW,KAAK,OAAO,EAAE,CAAC;YAC5B,MAAM,KAAK,GAAY,WAAsB,CAAC;QAChD,CAAC;QACD,MAAM,OAAO,GAAW,WAAgC,CAAC;IAC3D,CAAC;AACH,CAAC","sourcesContent":["/**\n * Represents a primitive JavaScript type string, number, bigint and symbol.\n */\ntype Primitive<T> = T extends string\n  ? string\n  : T extends number\n    ? number\n    : T extends bigint\n      ? bigint\n      : T extends symbol\n        ? symbol\n        : unknown;\n\n/**\n * This is a unique symbol that we declare. This symbol is used as a property key in our\n * $NonExhaustive type. The use of a unique symbol guarantees that this property won't conflict with\n * any other string-named properties that might exist.\n */\ndeclare const __non_exhaustive: unique symbol;\n/**\n * This is a mapped type that represents an object with a single optional property. The property key\n * is the __non_exhaustive symbol we declared earlier, and the property value is of type never.\n */\ntype $NonExhaustive = { [__non_exhaustive]?: never };\n/**\n * This is the main type we will use to define our extensible enums. It is a union of T and a type\n * intersection of Primitive<T> and $NonExhaustive. This effectively means that the type can be any\n * value of T or any other value that matches the primitive type of T. The intersection with\n * $NonExhaustive is what prevents TypeScript from collapsing the union with string into just\n * string.\n */\nexport type NonExhaustive<T> = T | (Primitive<T> & $NonExhaustive);\n\nexport type Color = NonExhaustive<\"red\" | \"blue\">;\n\nfunction operation(color: Color) {\n  return color;\n}\n\n// Completions are good\nconst knownColor: Color = \"red\";\n// No cast required here\nconst unknownColor: Color = \"green\";\nconst outputColor = operation(knownColor);\n\nif (outputColor === \"red\") {\n  // Bad behavior: this assignment requires a type cast\n  const red: \"red\" = outputColor as \"red\";\n} else {\n  // Good behavior - the contextual type here wouldn't break if a new variant were added\n  // Error message is not good\n  // @ts-expect-error\n  const maybeBlue: \"blue\" = outputColor;\n  if (outputColor === \"blue\") {\n    // Bad behavior: this assignment requires a type cast\n    const blue: \"blue\" = outputColor as \"blue\";\n  } else {\n    if (outputColor === \"green\") {\n      const green: \"green\" = outputColor as \"green\";\n    }\n    const unknown: string = outputColor as unknown as string;\n  }\n}\n"]}